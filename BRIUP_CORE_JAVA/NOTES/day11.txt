第十一天：

教学任务： 

        第九章  AWT事件模型 , 共 25 个slide(222-247);

目标： 

------------------------------------------------------------

第九章：The AWT Event Model 


知识点：一. 概念

            当用户与GUI交互，比如移动鼠标、按下鼠标键、单击Button按钮、在文本框内输入文本、选择菜单项或者关闭窗口时, 
            GUI会接受到相应的事件。

            . 事件对象： 在Java中，用事件对象来描述事件，事件对象对应的类一般均是Java语言直接提供。自已很少构建事件对象类；
            . 事件源：   触发事件的组件都被当做事件源，事件源发出事件；
            . 事件侦听器：对事件进行处理的对象；

            每一种事件都对应专门的监听器。监听器负责接收和处理这种事件。一个事件源可以触发多种事件，如果它注册了某种事件
            的监听器，那么这种事件就会被接收和处理。

        二. 事件对象

            事件对象描述了事件，是抽象事件的具体化。那事件对象类里究竟有什么呢？可以没有什么特殊的东西，它的存在本身已经
            代表了事件。 事件就是事件类的一个实例，不同的事件类实例，代表不同的事件。

            事件类里可以什么都没有，但不能少一样东西，那就是产生事件的事件源。事件源和事件对象息息相关，事件对象一定是某
            个事件源发出的。为了体现它们的这种紧密关系，在创造事件对象便要求指定事件源。它们这种关系在类与类间叫做组件关
            系，has a 关系。

        
        三. 事件源

            1. 是一个组件或对象，用来产生事件；
               通过事件源来实例化事件类型对象；
            2. 提供方法增加和删除事件监听器
            3. 维持一系列有兴趣的事件监听器
               事件源产生事件后，必须将事件对象传递给事件监听器, 让事件监听器去处理。因此事件源必须能够访问到事件监听器
               对象。如何访问呢？可以将事件监听器作为事件源的属性或事件监听器数组、集合类型作为事件源的属性；

               所谓增加或删除事件监听器无非是修改事件监听器属性的值；
             
            4. 逻辑上包括了创建和传递适当类型的事件对象给所有感兴趣的事件监听器

               事件对象产生后，如何真实地让事件监听器的代码执行呢？这时可调用对应的事件监听器中对应的方法；因此事件源中
               要提供一些代码，将事件对象传给所有感兴趣的事件监听器；

        四. 事件监听器

            1. 一个接口，该接口中声明一些方法用来处理事件；
            2. 该接口继承自java.util.EventListener;

            讲解完书上例子之后， 自行做一个练习：练习一下自定义事件对象、事件源、事件监听器，对这些概念有一个更深的感受；

        五. AWT 事件类型

            JDK类库中已经为GUI编程准备好了事件，所有的具体AWT事件类都位于java.awt.event包中，并且继承
            java.awt.AWTEvent，AWTEvent则继承Eventobject类。事件类的层次结构如课件上图示：

            EventObject类有一个getSource()方法，它用来返回触发事件的对象。
            ComponentEvent类还提供了一个getComponent()方法，用来返回触发事件的组件, 这两个方法返回同一个事件源对象的引用。
 
        六. ActionEvent

            讲解书上例子，练习：ch10.ActionEventTest.java

        七. AWT事件监听器

            每类事件都有一个监听接口。监听接口中定义了一个或多个处理事件的方法。当发生特定的事件时，AWT会决定调用哪个方法。

            mouseDragged(MouseEvent e):按住鼠标键拖动触发
            mouseMoved(MouseEvent)：不按住鼠标键移动触发

            Void keyPressed(KeyEvent?e)  按下键盘触发
           ?void keyReleased(KeyEvent?e) 释放键盘触发
           ?void keyTyped(KeyEvent?e)  当按一个键盘打字的时候触发

            Void adjustmentValueChanged(AdjustmentEvent?e) 当一个可调整的值被改变的时候触发

	    WindowClosing(WindowEvent)：当用户企图关闭一个窗口时触发
            windowOpened(WindowEvent)：当窗口第一次被打开时触发
            windowIconified(WindowEvent)：当窗口最小化时触发
            windowDeiconified(WindowEvent)：当窗口最大化时触发
            windowClosed(WindowEvent)：当窗口被关闭后作为重新部署的结果时触发
            windowedActivated(WindowEvent)：当窗口被设置成活动窗口时触发
            windowDeactivated(WindowEvent)：当窗口不再是活动窗口时触发

       八.  事件适配器

            1) 一个适配器用空实现体实现了一个特殊的监听器
            2) 你正好可以定义一个子类继承这个适配器（或者采用匿名内部类隐式地继承了一个父类适配器）覆盖适配器中你所感兴趣
               的方法

            顺带总结一下实现监听接口方式：

            1. 用内部类实现监听接口；
            2. 用容器类实现监听接口；
            3. 定义专门的顶层类实现监听接口；
            4. 采用事件适配器
 
            练习：实现一简单计算器
           

               


























